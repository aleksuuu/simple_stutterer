/*
    Modified from Waveset chopper / repeater by Graham Wakefield
*/

/*
	Waveset chopper / repeater

	This program divides the input into segments, and plays these segments back.
	It could be seen as a time-domain, granular form of analysis/resynthesis.
	
	The program contains a recording section, 
		which stores grains into a Data object (segment_data)
	and a playback section,
		which selects and plays these grains one-by-one
	
	The grains are not enveloped; 
		instead the input is segmented at points where the signal is rising and crosses zero
		
	A positive zero-crossing means that: 
		a: previous sample is less than zero
		b: next sample is greater than zero
	
	For pure sounds a segment corresponds to one or more wavecycles, 
		but for complex sounds it can be somewhat stochastic.
	
	RECORDING:
		
	Since waveforms rarely cross zero at an exact sample location, 
		the actual crossing is somewhere between a and b.
		The program estimates this sub-sample crossing phase (and stores it in offset_data)
		It also stores the sub-sample accurate segment length (in length_data)
		
	The segment_data recorded includes the sample just before the first crossing,
		and the sample just after the last, in order to contain both actual crossings.
		I.e. each captured segment looks like [a1, b1, ... b2 a2 ... a3, b3]
	
	When a segment finishes recording, a new segment is chosen to write into (write_chan)
	
	PLAYBACK:
	
	The playback section is continuously playing a segment (play_chan)
		
	Playback includes additional calculations,
 		to ensure the sub-sample phase offset is used and retained between segments

	When the segment playback is done (possibly after several repeats),
		a new segment is selected according to the current strategy (play_mode)
		
		
	Graham Wakefield 2012
*/


// the segment storage (each segment on its own channel):
Data segment_data(10004, 1); // 10004

// hold the current playback segment:
Param hold(0, min=0, max=1);

Param min_len(2500, min=1000, max=10000);
Param max_len(4000, min=1000, max=10000);
Param fade_len(300, min=10, max=500);
Param gap_len(100, min=0, max=200);

// the number of samples since the last capture:
History write_index(10000);
// the sample index of playback:
History play_index(0);

History prev_hold;

History segment_len(10000);

output = in1;
// record the next 2940 samps if hold state switches from false to true
if (hold) {
	if (!prev_hold) {
		write_index = 0;
		play_index = 0;
		segment_len = scale(noise(), -1, 1, min_len, max_len);
	}
	if (write_index < segment_len) {
		amp = 1;
		if (write_index < fade_len) {
			amp = write_index / fade_len;
		} else if (write_index > segment_len - fade_len - gap_len) {
			amp = clip((segment_len - write_index - 1) / fade_len, 0, 1);
		}
		poke(segment_data, in1 * amp, write_index);
		write_index += 1;
	} else {
		output += peek(segment_data, play_index);
		play_index = wrap(play_index + 1, 0, segment_len);
	}
} else {
	if (play_index < segment_len - 1) {
		output += peek(segment_data, play_index);
		play_index = play_index + 1; // no wrap this time because of the if; this is to prevent clicks
	}
}

out1 = output;
out2 = segment_len;

prev_hold = hold;